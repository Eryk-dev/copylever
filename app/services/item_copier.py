"""
Core logic for copying ML listings from one seller to another.
"""
import logging
from typing import Any

from app.db.supabase import get_db
from app.services.ml_api import (
    get_item,
    get_item_description,
    get_item_compatibilities,
    create_item,
    set_item_description,
    copy_item_compatibilities,
)

logger = logging.getLogger(__name__)

# Attributes to exclude (read-only or auto-generated by ML)
EXCLUDED_ATTRIBUTES = {
    "ITEM_CONDITION",  # set via `condition` field
    "SELLER_SKU",      # keep if present in variations
}

# Top-level fields to NOT copy (auto-generated)
SKIP_FIELDS = {
    "id", "seller_id", "date_created", "start_time", "stop_time",
    "sold_quantity", "status", "permalink", "thumbnail", "thumbnail_id",
    "secure_thumbnail", "health", "tags", "catalog_listing",
    "automatic_relist", "last_updated", "base_price",
    "initial_quantity", "official_store_id", "catalog_product_id",
    "domain_id", "parent_item_id", "deal_ids", "subtitle",
    "differential_pricing", "original_price",
}


def _build_item_payload(item: dict) -> dict:
    """Build POST /items payload from source item data."""
    payload: dict[str, Any] = {}

    # Basic fields
    for field in [
        "title", "category_id", "price", "currency_id",
        "available_quantity", "buying_mode", "listing_type_id",
        "condition", "video_id",
    ]:
        if field in item and item[field] is not None:
            payload[field] = item[field]

    # Pictures — ML accepts source URLs
    if item.get("pictures"):
        payload["pictures"] = [
            {"source": pic.get("secure_url") or pic.get("url")}
            for pic in item["pictures"]
            if pic.get("secure_url") or pic.get("url")
        ]

    # Attributes — filter out read-only ones
    if item.get("attributes"):
        attrs = []
        for attr in item["attributes"]:
            attr_id = attr.get("id", "")
            if attr_id in EXCLUDED_ATTRIBUTES:
                continue
            # Keep only id and value_name (or value_id if structured)
            clean = {"id": attr_id}
            if attr.get("value_id"):
                clean["value_id"] = attr["value_id"]
            if attr.get("value_name"):
                clean["value_name"] = attr["value_name"]
            attrs.append(clean)
        if attrs:
            payload["attributes"] = attrs

    # Sale terms
    if item.get("sale_terms"):
        terms = []
        for term in item["sale_terms"]:
            clean = {"id": term.get("id")}
            if term.get("value_id"):
                clean["value_id"] = term["value_id"]
            if term.get("value_name"):
                clean["value_name"] = term["value_name"]
            terms.append(clean)
        if terms:
            payload["sale_terms"] = terms

    # Shipping
    if item.get("shipping"):
        ship = item["shipping"]
        payload["shipping"] = {
            "mode": ship.get("mode", "me2"),
            "local_pick_up": ship.get("local_pick_up", False),
            "free_shipping": ship.get("free_shipping", False),
        }
        if ship.get("methods"):
            payload["shipping"]["methods"] = ship["methods"]

    # Variations
    if item.get("variations"):
        variations = []
        for var in item["variations"]:
            v: dict[str, Any] = {}

            if var.get("available_quantity") is not None:
                v["available_quantity"] = var["available_quantity"]
            if var.get("price") is not None:
                v["price"] = var["price"]

            # Variation pictures
            if var.get("picture_ids"):
                v["picture_ids"] = var["picture_ids"]

            # Variation attribute combinations
            if var.get("attribute_combinations"):
                v["attribute_combinations"] = [
                    {
                        "id": ac.get("id"),
                        **({"value_id": ac["value_id"]} if ac.get("value_id") else {}),
                        **({"value_name": ac["value_name"]} if ac.get("value_name") else {}),
                    }
                    for ac in var["attribute_combinations"]
                ]

            # Variation attributes (seller_custom_field, etc.)
            if var.get("attributes"):
                v["attributes"] = [
                    {
                        "id": a.get("id"),
                        **({"value_name": a["value_name"]} if a.get("value_name") else {}),
                    }
                    for a in var["attributes"]
                ]

            variations.append(v)

        if variations:
            payload["variations"] = variations

    # Channels
    if item.get("channels"):
        payload["channels"] = item["channels"]

    return payload


async def copy_single_item(
    source_seller: str,
    dest_seller: str,
    item_id: str,
    user_email: str | None = None,
) -> dict:
    """
    Copy a single item from source_seller to dest_seller.
    Returns result dict with status and details.
    """
    result = {
        "source_item_id": item_id,
        "dest_seller": dest_seller,
        "status": "pending",
        "dest_item_id": None,
        "error": None,
    }

    try:
        # 1. GET full item data from source
        logger.info(f"Fetching item {item_id} from {source_seller}")
        item = await get_item(source_seller, item_id)

        # 2. GET description
        description_data = await get_item_description(source_seller, item_id)
        plain_text = description_data.get("plain_text", "")

        # 3. Check for compatibilities
        has_compat = False
        try:
            compat = await get_item_compatibilities(source_seller, item_id)
            has_compat = compat is not None and bool(compat)
        except Exception as e:
            logger.warning(f"Could not fetch compatibilities for {item_id}: {e}")

        # 4. Build payload and POST to dest seller
        payload = _build_item_payload(item)
        logger.info(f"Creating item on {dest_seller} (title: {payload.get('title', '')[:50]})")
        new_item = await create_item(dest_seller, payload)
        new_item_id = new_item["id"]
        result["dest_item_id"] = new_item_id
        logger.info(f"Item created: {new_item_id} on {dest_seller}")

        # 5. POST description
        if plain_text:
            try:
                await set_item_description(dest_seller, new_item_id, plain_text)
                logger.info(f"Description set for {new_item_id}")
            except Exception as e:
                logger.warning(f"Failed to set description for {new_item_id}: {e}")

        # 6. Copy compatibilities (using ML native copy)
        if has_compat:
            try:
                await copy_item_compatibilities(dest_seller, new_item_id, item_id)
                logger.info(f"Compatibilities copied for {new_item_id} from {item_id}")
            except Exception as e:
                logger.warning(f"Failed to copy compatibilities for {new_item_id}: {e}")

        result["status"] = "success"

    except Exception as e:
        logger.error(f"Failed to copy {item_id} to {dest_seller}: {e}")
        result["status"] = "error"
        result["error"] = str(e)

    return result


async def copy_items(
    source_seller: str,
    dest_sellers: list[str],
    item_ids: list[str],
    user_email: str | None = None,
) -> list[dict]:
    """
    Copy multiple items to multiple destination sellers.
    Logs each copy to copy_logs table.
    """
    db = get_db()
    all_results = []

    for item_id in item_ids:
        item_id = item_id.strip()
        if not item_id:
            continue

        dest_item_ids = {}
        item_status = "success"
        item_errors = {}

        for dest_seller in dest_sellers:
            result = await copy_single_item(source_seller, dest_seller, item_id, user_email)
            all_results.append(result)

            if result["status"] == "success":
                dest_item_ids[dest_seller] = result["dest_item_id"]
            else:
                item_status = "partial" if dest_item_ids else "error"
                item_errors[dest_seller] = result["error"]

        # Log to copy_logs
        try:
            db.table("copy_logs").insert({
                "user_email": user_email,
                "source_seller": source_seller,
                "dest_sellers": dest_sellers,
                "source_item_id": item_id,
                "dest_item_ids": dest_item_ids,
                "status": item_status,
                "error_details": item_errors if item_errors else None,
            }).execute()
        except Exception as e:
            logger.error(f"Failed to log copy for {item_id}: {e}")

    return all_results

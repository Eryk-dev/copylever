{
  "project": "Copy Anuncios ML",
  "branchName": "ralph/copy-compatibilities",
  "description": "Nova view para copiar compatibilidades de veículos de um anúncio fonte para múltiplos anúncios de destino (identificados por SKU) em todas as contas conectadas do Mercado Livre",
  "userStories": [
    {
      "id": "US-001",
      "title": "Create compat_logs Supabase migration",
      "description": "As a developer, I want the compat_logs table created in Supabase so that compatibility copy operations can be logged",
      "acceptanceCriteria": [
        "Create file app/db/migrations/001_compat_logs.sql with CREATE TABLE statement",
        "Table compat_logs has columns: id (BIGSERIAL PK), source_item_id (TEXT NOT NULL), skus (TEXT[] NOT NULL), targets (JSONB NOT NULL), total_targets (INT NOT NULL), success_count (INT NOT NULL), error_count (INT NOT NULL), created_at (TIMESTAMPTZ DEFAULT NOW())",
        "SQL file is valid and can be run against Supabase",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-002",
      "title": "Add search_items_by_sku to ml_api.py",
      "description": "As a developer, I want a function to search items by seller SKU via ML API so that the compat feature can find target items across all accounts",
      "acceptanceCriteria": [
        "Add async function search_items_by_sku(seller_slug: str, sku: str) -> list[str] to app/services/ml_api.py",
        "Function calls GET /users/{user_id}/items/search with params seller_sku={sku} using the seller's access token",
        "To get user_id, query copy_sellers table for ml_user_id matching the seller_slug",
        "Returns list of item_id strings found for that SKU",
        "Returns empty list if no items found (does not raise on 404)",
        "Uses _get_token(seller_slug) for authentication, same pattern as existing functions",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "ML API endpoint: GET https://api.mercadolibre.com/users/{user_id}/items/search?seller_sku={sku} — returns { results: [item_ids], paging: {...} }. The ml_user_id is stored in the copy_sellers table."
    },
    {
      "id": "US-003",
      "title": "Create compat_copier.py orchestration service",
      "description": "As a developer, I want an orchestration service that searches SKUs across all sellers and copies compatibilities in batch",
      "acceptanceCriteria": [
        "Create file app/services/compat_copier.py",
        "Add async function search_sku_all_sellers(skus: list[str]) -> list[dict] that queries all sellers from copy_sellers table and calls search_items_by_sku for each seller+SKU combination using asyncio.gather for parallelism",
        "Each result dict contains: seller_slug, seller_name, item_id, sku",
        "For each item_id found, fetch basic item info (title) via get_item() to include in results",
        "Add async function copy_compat_to_targets(source_item_id: str, targets: list[dict]) -> list[dict] that calls copy_item_compatibilities for each target and returns results with status/error per target",
        "copy_compat_to_targets logs the operation to compat_logs table in Supabase after completion",
        "Individual target errors do not stop processing of remaining targets",
        "Import search_items_by_sku, copy_item_compatibilities, get_item from ml_api",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Reuse existing functions from app/services/ml_api.py: copy_item_compatibilities(seller_slug, new_item_id, source_item_id), get_item(seller_slug, item_id). Use app/db/supabase.py get_db() to access the database. Pattern: db = get_db(); db.table('copy_sellers').select('slug, name, ml_user_id').execute()"
    },
    {
      "id": "US-004",
      "title": "Create compat router with all endpoints",
      "description": "As a developer, I want API endpoints for the compatibility copy feature so the frontend can interact with the backend",
      "acceptanceCriteria": [
        "Create file app/routers/compat.py with APIRouter prefix='/api/compat' and dependencies=[Depends(require_admin)]",
        "GET /api/compat/preview/{item_id}?seller={slug} — returns item preview (id, title, thumbnail, has_compatibilities, compat_count). Use get_item and get_item_compatibilities from ml_api. The seller param is needed to authenticate the API call — use any connected seller if not provided (query first seller from copy_sellers table)",
        "POST /api/compat/search-sku — accepts body { skus: list[str] }, calls search_sku_all_sellers, returns list of found items grouped by SKU",
        "POST /api/compat/copy — accepts body { source_item_id: str, targets: list[{ seller_slug: str, item_id: str }] }, calls copy_compat_to_targets, returns summary with total/success/errors and per-target results",
        "GET /api/compat/logs — returns compat_logs ordered by created_at desc, limit 50",
        "Register router in app/main.py: add 'from app.routers import auth, auth_ml, copy, compat' and app.include_router(compat.router)",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Follow exact same patterns as app/routers/copy.py. Import require_admin from app.routers.auth. Use Pydantic BaseModel for request bodies. For preview, the seller parameter is a query param used to authenticate the ML API call — the frontend will pass any connected seller slug."
    },
    {
      "id": "US-005",
      "title": "Create CompatPage frontend with source input and SKU search",
      "description": "As an operator, I want a dedicated page to input the source listing and search for target items by SKU across all accounts",
      "acceptanceCriteria": [
        "Create file frontend/src/pages/CompatPage.tsx",
        "Page has an input field for source item (accepts ML URL or item_id directly)",
        "Parse MLB item_id from ML URLs using regex: extract MLB followed by digits, removing hyphens (e.g. MLB-1234567890 becomes MLB1234567890). Pattern: /MLB[-]?(\\d+)/i then format as MLB{digits}",
        "On blur or Enter in source field, call GET /api/compat/preview/{item_id}?seller={first_seller_slug} and display preview (title, thumbnail, compatibility count)",
        "If item has no compatibilities, show warning message and disable the copy flow",
        "Textarea field for SKUs (placeholder: 'Digite os SKUs separados por vírgula, espaço ou quebra de linha')",
        "Button 'Buscar Anúncios' that POSTs to /api/compat/search-sku with parsed SKUs array",
        "Display search results as a list grouped by seller showing: seller name, item_id, title for each found item",
        "Show warning for SKUs that returned no results",
        "Button 'Copiar Compatibilidades' (disabled until search results exist and source has compatibilities) that POSTs to /api/compat/copy with source_item_id and all found targets",
        "Show progress indicator during copy (loading state)",
        "Show results summary after copy: X successes, Y errors, with per-item detail",
        "Add compat-related TypeScript interfaces to frontend/src/lib/api.ts: CompatPreview, CompatSearchResult, CompatCopyResult",
        "Component receives props: sellers (Seller[]) and headers (Record<string,string>) same as CopyPage",
        "Follow existing design system from index.css (use CSS variables --ink, --paper, --surface, --line, --success, --danger, etc.) and match the visual style of CopyPage",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": false,
      "notes": "Use fetch() with API_BASE from lib/api.ts for all API calls, same pattern as existing pages. The sellers prop comes from useAuth hook in App.tsx. Use the first seller's slug for the preview API call. For SKU parsing, split input by commas, spaces, and newlines then trim and filter empty strings."
    },
    {
      "id": "US-006",
      "title": "Add Compat tab to App.tsx navigation and history section",
      "description": "As an operator, I want to access the Compat page via a tab in the header navigation and see operation history",
      "acceptanceCriteria": [
        "In frontend/src/App.tsx, add 'compat' to the View type: type View = 'copy' | 'admin' | 'compat'",
        "Add a third ViewTab in the nav: <ViewTab active={view === 'compat'} onClick={() => setView('compat')}>Compat</ViewTab>",
        "Import CompatPage and render it when view === 'compat': <CompatPage sellers={auth.sellers} headers={auth.headers} />",
        "In CompatPage.tsx, add a history section below the form that fetches GET /api/compat/logs on mount",
        "History displays: date (formatted), source item_id, SKUs list, total targets, success count, error count",
        "History updates after each copy operation completes",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": "Follow the exact same pattern used for CopyPage and Admin views in App.tsx. The history section should be similar to the copy logs pattern in CopyPage.tsx."
    }
  ]
}

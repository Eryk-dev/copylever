# Ralph Progress Log
Started: Fri Feb 27 14:21:08 -03 2026
---

## Codebase Patterns
- Use `_post_with_retry` / `_put_with_retry` for ML API calls that may hit 429 rate limits
- `get_item_compatibilities()` returns `None` for 404 (no compats) or a dict with `products` list
- `copy_item_compatibilities` has `mode` param (default "add") — callers that don't pass it get backward-compatible behavior
- mypy is the typecheck tool: `python3 -m mypy <file>` — pyright not installed
- User Product items are pre-detected via `dest_item.get("user_product_id")` and routed to `/copy-paste` endpoint
- `_copy_user_product_copy_paste()` needs `domain_id` — passed via `source_domain_id` param or fetched from source compats as fallback
- New DB columns need a migration SQL file in `app/db/migrations/` — use `ALTER TABLE ... ADD COLUMN IF NOT EXISTS`
- Use `Literal["a", "b"]` from `typing` for Pydantic field validation on fixed option sets

## 2026-02-27 - US-001
- Implemented POST vs PUT logic in `copy_item_compatibilities` based on destination existing compats
- Added `_put_with_retry` helper (mirrors `_post_with_retry` for PUT requests)
- Added `mode: str = "add"` parameter — `add` appends, `replace` deletes existing then creates
- When `has_existing` and `mode='replace'`: extracts `catalog_product_id` from dest compats for the PUT delete body
- When `has_existing` and `mode='add'`: PUT with only `create` key
- When no existing compats: POST regardless of mode (nothing to delete)
- Kept `_is_user_product_error` fallback as required
- Added info-level logging of HTTP method used (POST or PUT)
- Files changed: `app/services/ml_api.py`
- **Learnings for future iterations:**
  - `dest_compat.get("products", [])` needs `# type: ignore[union-attr]` when dest_compat could be None (but is guarded by `has_existing` check)
  - The `source_compat_products` param is kept for backward compat with `item_copier.py` — don't remove until US-002 changes the flow
  - Callers: `compat_copier.py:118` and `item_copier.py:792` — both work fine with default `mode="add"`
---

## 2026-02-27 - US-002
- Replaced legacy User Product flow with new `/copy-paste` endpoint
- Added `_copy_user_product_copy_paste()` function calling `POST /user-products/{id}/compatibilities/copy-paste`
- Pre-detects User Product items in `copy_item_compatibilities` via `get_item()` → `user_product_id` field
- Request body: `domain_id`, `category_id`, `item_id`, `extended_information` (never sends `user_product_id` in body)
- Added `source_domain_id: str | None = None` parameter — falls back to fetching from source compats if not provided
- Deleted legacy `_copy_user_product_compatibilities()` (old batch approach)
- Deleted legacy `_is_user_product_error()` detection function
- Removed `_is_user_product_error` fallback check from `copy_item_compatibilities`
- Removed unused constants `_UP_COMPAT_BATCH` and `_COMPAT_PACE`
- Files changed: `app/services/ml_api.py`
- **Learnings for future iterations:**
  - `get_item()` returns full item data including `user_product_id` and `category_id` — useful for detecting User Product items
  - The `/copy-paste` endpoint is simpler than the old batch approach — single POST with source item_id does all the work
  - `source_compat_products` param is still in the signature for backward compat with `item_copier.py` but is no longer used internally
  - US-003 will wire `source_domain_id` through `compat_copier.py` so the fallback fetch in `_copy_user_product_copy_paste` is avoided
---

## 2026-02-27 - US-003
- Added `mode: Literal["add", "replace"] = "add"` field to `CopyRequest` model in `app/routers/compat.py`
- Pydantic `Literal` type provides automatic validation — rejects any value other than "add" or "replace"
- Passed `req.mode` to `copy_compat_to_targets()` background task call
- Added `mode` to `in_progress` log row inserted into `compat_logs` table
- Added `mode: str = "add"` parameter to `copy_compat_to_targets()` in `app/services/compat_copier.py`
- Extracted `source_domain_id` from pre-fetched source compats: `source_compat_products[0].get("domain_id")`
- Passed both `mode` and `source_domain_id` to each `copy_item_compatibilities()` call
- Created migration `006_compat_logs_mode.sql` to add `mode` column to `compat_logs` table
- Files changed: `app/routers/compat.py`, `app/services/compat_copier.py`, `app/db/migrations/006_compat_logs_mode.sql`
- **Learnings for future iterations:**
  - Use `Literal["add", "replace"]` from `typing` for Pydantic field validation — cleaner than manual validation
  - The `compat_logs` table needs a migration for any new columns — SQL files in `app/db/migrations/` are applied manually
  - `source_compat_products[0].get("domain_id")` safely extracts domain_id; guarded by `if source_compat_products` check
  - All params flow: CopyRequest → copy_compat endpoint → bg.add_task → copy_compat_to_targets → copy_item_compatibilities
---

## 2026-02-27 - US-004
- Added `mode` state (`'add' | 'replace'`, default `'add'`) to CompatPage
- Added "Modo de copia" Card with a `<select>` between search results and copy button
- Options: "Adicionar às existentes" (add) and "Substituir todas" (replace)
- Wired `mode` into the POST `/api/compat/copy` request body
- Added `mode` to `handleCopy` useCallback dependency array
- Styling follows existing patterns: CSS variables, `input-base` class, same border/radius/font
- Files changed: `frontend/src/pages/CompatPage.tsx`
- **Learnings for future iterations:**
  - The `Card` component from `CopyPage` supports `title` prop and wraps children — reuse it for new UI sections
  - Use `className="input-base"` on `<select>` elements to match existing input styling
  - `useCallback` deps must include all state vars used in the callback body (e.g., `mode`)
---
